imports
{
import CCO.SourcePos
import CCO.HM.Base
import CCO.SystemF.Base

import Data.List
import Debug.Trace
}

-------------------------------------------------------------------------------
-- Syntax
-------------------------------------------------------------------------------


--SF : data Ty
--SF :   | TyVar   a :: {TyVar}
--SF :   | Arr     ty1 :: Ty  ty2 :: Ty
--SF :   | Forall  a :: {TyVar}  ty1 :: Ty
--SF : 
--SF : data Tm
--SF :   | Var    x :: {Var}
--SF :   | Lam    x :: {Var}  ty :: Ty  t1 :: Tm
--SF :   | App    t1 :: Tm  t2 :: Tm
--SF :   | TyLam  a :: {TyVar}  t1 :: Tm
--SF :   | TyApp  t1 :: Tm  ty :: Ty
--
--HM : data Tm
--HM :   | Tm  pos :: {SourcePos}  t :: Tm_
--HM : 
--HM : data Tm_
--HM :   | Var  x :: {Var}
--HM :   | Lam  x :: {Var}  t1 :: Tm
--HM :   | App  t1 :: Tm  t2 :: Tm
--HM :   | Let  x :: {Var}  t1 :: Tm  t2 :: Tm

attr HMTm HMTm_
    syn algoW           :: {(SFTm,Ty,TySubst)}
    inh typeEnvironment :: {TyEnv}
 
attr HMTm HMTm_
    chn counter :: {Int}

sem HMTm
    | HMTm lhs.counter = @lhs.counter+1


sem HMTm
    | HMTm lhs.algoW = @t.algoW

sem HMTm_
    | Var lhs.algoW = if elem @x (map fst @lhs.typeEnvironment)
                        then (SFVar @x, inst (getVar @x @lhs.typeEnvironment), Identity)
                        else error ("Variable "++ @x ++" not found in environment.")
    | Lam lhs.algoW = let (sft1, tau2, theta1) = @t1.algoW
                      in  (sft1
                          , Arrow (applySubst theta1 @loc.freshVariable) (tau2)
                          , theta1
                          )
          loc.freshVariable = Alpha ('v' : show @lhs.counter) -- a fresh variable, hopefully.
    | App lhs.algoW = let (sft1, tau1, theta1) = @t1.algoW
                          (sft2, tau2, theta2) = @t2.algoW
                          theta3               = unify 
                                                    (applySubst theta2 tau1) 
                                                    (Arrow tau2 @loc.freshVariable)
                      in  undefined
          loc.freshVariable = Alpha ('v' : show @lhs.counter) -- a fresh variable, hopefully.
    | Let lhs.algoW = (SFVar "s", Alpha "Bool", Identity)

sem HMTm_
    | Lam t1.typeEnvironment = (@x, PlainTy @loc.freshVariable) : @lhs.typeEnvironment 


{
getVar :: Var -> TyEnv -> TyScheme
getVar x env = case lookup x env of
                Just scheme -> scheme
                _           -> error ("This shouldn't happen. "
                                ++x++" wasn't found in the environment.")

gen :: TyEnv -> Ty -> TyScheme
gen env tau = let free = ftvT tau \\ ftvTE env
              in  wrapForall free tau

wrapForall :: [Var] -> Ty -> TyScheme
wrapForall []     t = PlainTy t
wrapForall (v:vs) t = Forall v (wrapForall vs t)

inst :: TyScheme -> Ty
inst (PlainTy t)  = t
inst (Forall t s) = undefined

unify :: Ty -> Ty -> TySubst
unify t1 t2 = trace "unify" undefined

ftvT :: Ty -> [Var]
ftvT (Alpha tv)    = [tv]
ftvT (Arrow t1 t2) = nub(ftvT t1 ++ ftvT t2)

ftvTS :: TyScheme -> [Var]
ftvTS (PlainTy t)    = ftvT t
ftvTS (Forall tv ts) = nub (ftvTS ts) \\ [tv]

ftvTE :: TyEnv -> [Var]
ftvTE []         = []
ftvTE ((v,ts):r) = ftvTS ts ++ ftvTE r
}

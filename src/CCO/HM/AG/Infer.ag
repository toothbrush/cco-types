imports
{
import Data.List

import Debug.Trace
}

attr Tm Tm_
    syn inferredType :: {Ty}
    syn substitution :: {TySubst}
    inh typeEnvironment :: {TyEnv} -- DONE I think...
    chn counter :: {Int} -- Useful for creating unique, fresh variables

attr Tm
    syn annotated :: {SF.Tm}

sem Tm
    | Tm loc.num :: uniqueref counter
sem Tm_
    | Var loc.num :: uniqueref counter
    | Lam loc.num :: uniqueref counter
    | App loc.num :: uniqueref counter
    | Let loc.num :: uniqueref counter 


-- SF : data Ty
-- SF :   | TyVar   a :: {TyVar}
-- SF :   | Arr     ty1 :: Ty  ty2 :: Ty
-- SF :   | Forall  a :: {TyVar}  ty1 :: Ty
-- SF : data Tm
-- SF :      | Var    x :: {Var}
-- SF :      | Lam    x :: {Var}  ty :: Ty  t1 :: Tm
-- SF :      | App    t1 :: Tm  t2 :: Tm
-- SF :      | TyLam  a :: {TyVar}  t1 :: Tm
-- SF :      | TyApp  t1 :: Tm  ty :: Ty
--
-- HM : data Tm
-- HM :   | Tm  pos :: {SourcePos}  t :: Tm_
-- HM : 
-- HM : data Tm_
-- HM :   | Var  x :: {Var}
-- HM :   | Lam  x :: {Var}  t1 :: Tm
-- HM :   | App  t1 :: Tm  t2 :: Tm
-- HM :   | Let  x :: {Var}  t1 :: Tm  t2 :: Tm

sem Tm_
    | Lam t1.typeEnvironment = (@x, freshVar @loc.num) : @lhs.typeEnvironment
    | App t2.typeEnvironment = applySubst @t1.substitution @lhs.typeEnvironment
    | Let t2.typeEnvironment = let newEnv = applySubst @t1.substitution @lhs.typeEnvironment
                               in  (@x, gen newEnv @t1.inferredType) : newEnv

-- SOME WORK HERE ?? 
-- sem Tm
--     | apply the generalise function!
sem Tm
    | Tm  lhs.annotated = undefined

sem Tm_
    | Var lhs.substitution   = Identity
    | Lam lhs.substitution   = @t1.substitution
    | App lhs.substitution   = let theta1 = @t1.substitution
                                   theta2 = @t2.substitution
                                   theta3 = unify (applySubst theta2 @t1.inferredType) (Arr (@t2.inferredType) (freshVar @loc.num))
                               in Dot theta3 (Dot theta2 theta1)
    | Let lhs.substitution   = let theta1 = @t1.substitution
                                   theta2 = @t2.substitution
                               in  Dot theta2 theta1

sem Tm_
    | Var lhs.inferredType   = if elem @x (map fst @lhs.typeEnvironment) -- TODO: check this!
                                then inst (getVar @x @lhs.typeEnvironment)
                                else error ("Variable "++ @x ++" not found in environment.")
    | Lam lhs.inferredType   = let theta1 = @t1.substitution
                                   alpha1 = freshVar @loc.num
                                   tau2   = @t1.inferredType
                               in  Arr (applySubst theta1 alpha1) tau2
    | App lhs.inferredType   = let alpha1 = freshVar @loc.num
                                   theta2 = @t2.substitution
                                   theta3 = unify (applySubst theta2 @t1.inferredType) (Arr (@t2.inferredType) alpha1)
                               in  applySubst theta3 alpha1
    | Let lhs.inferredType   = @t2.inferredType








{
freshVar :: Int -> Ty
freshVar i = TyVar $ 'v' : (show i)

inst :: Ty -> Ty
inst t@(TyVar _)    = t
inst t@(Arr t1 t2)  = trace "inst Arr (guessing!)" t
inst (Forall tv t1) = applySubst (Sub tv (TyVar fresh)) (inst t1)
                        where fresh = (tv ++ "'")

gen :: TyEnv -> Ty -> Ty
gen env tau = let free = ftv tau \\ ftv env
              in wrapForall free tau

wrapForall :: [Var] -> Ty -> Ty
wrapForall [] t = t
wrapForall (v:vs) t = Forall v (wrapForall vs t)

-- This gives us unique variable numbers
nextUnique :: Int -> (Int, Int)
nextUnique u = (u+1, u)

getVar :: Var -> TyEnv -> Ty
getVar x env = case lookup x env of
                Just scheme -> scheme
                _ -> error ("This shouldn't happen. " ++ x ++
                            " wasn't found in the environment.")

}
